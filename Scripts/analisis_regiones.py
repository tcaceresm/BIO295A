# -*- coding: utf-8 -*-
"""analisis_regiones.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aianu0BJp8rIPHaZXL7iqZZnR0pYD28o
"""

!pip install --upgrade plotly

import os
# Para permitir el acceso a archivos de google drive
from google.colab import drive
drive.mount('/content/drive')
# Imprime el directorio en el que se encuentra
os.getcwd()

# Commented out IPython magic to ensure Python compatibility.
# Se cambia de directorio donde se encuentras los archivos
# %cd '/content/drive/MyDrive/UC/7mo Semestre/bio295a/Colab Notebooks/295'

import pandas as pd
import numpy as np
import skimage.io as ski
import matplotlib.pyplot as plt
import plotly.express as px
#modulo preparado para el analisis
import analisis_regiones as analisis

# Se lista el contenido del directorio
!ls

"""# Análisis del set de imágenes de la *niña afgana*. 
Este set de datos corresponde a 162 fotos. La idea del análisis es escoger las  regiones de interés y ver cómo varía la intensidad de luminiscencia. Las regiones de interés se establecen de forma circular, al entregar la coordenada del centro de la región. Se genera un dataframe, o tabla de datos, donde se encontrarán los valores de intensidad de luminiscencia (en valor de pixel (u.a)). Además, se presenta un gráfico para ver de forma visual la variación de la intensidad de luminiscencia entre las regiones comparadas

"""

#Para iniciar, debemos abrir la imagen.

image = ski.imread('nina.tif') #se debe reemplazar el texto entre comillas por 
                               #el nombre de la imagen a analizar

#mostramos los primeros 25 frames de la imagen para tener una visualizaciónd de las imágenes.
#Esto toma un poco de tiempo
fig = px.imshow(image[0:25], animation_frame=0, binary_string=True, labels=dict(animation_frame="slice"), width=1000, height=1000)
fig.show()

#Si les aparece el error "TypeError: imshow() got an unexpected keyword argument 'animation frame", ejecutar primera celda

"""Explicación de los parámetros requeridos a continuación:
* El *numero de frames* corresponde a cuántas imagenes posee el archivo.
* *Coordenadas de la región backgroun*d: Se le solicita al usuario ingresar la coordenada X y luego la coordenada Y de la región establecida como background.
* El *valor de radio del background* corresponde al radio que poseerá la región background. Mayor radio, más grande será la zona.
* El *valor de radio* corresponde al radio que poseerán las regiones a comparar.
* La *coordenada X de la región* hace referencia a la coordenada X de una de las regiones de interes. Para el caso de la *coordenada Y* es lo mismo.

Se pueden agregar tantas coordenadas X e Y como sean necesarias. Cada par X, Y corresponde a una región.

"""

#Necesitamos algunos parametros para poder realizar el análisis
frames, background, radio, bck_radio, coordenadas = analisis.obtener_datos()

#Se muestra una segmentación en base a las regiones escogidas. Es una manera de
#verificar que las regiones a analizar son las que realmente deseamos.
import copy

image_copia = copy.copy(image) #generamos una copia de la imagen original. Es para no
                    #sobreescribir la imagen original

regiones_comparar = coordenadas #Son las coordenadas del centro de la región circular
                                #que analizaremos

imagen2_segmentada = analisis.segmentar(image_copia, regiones_comparar, radio=radio)
px.imshow(imagen2_segmentada, height=1000, width=1000)

#Ejecuto el análisis
df = analisis.analisis_nina2(image, coordenadas, background, radio, bck_radio, frames=frames)
#Proceso los valores para que queden entre 0 y 1
df_normalizado = analisis.normalize(df)

#En la siguiente dataframe tengo los valores de intensidad 
#para cada región. Esta contiene los valores no normalizados entre 0 y 1
df

#En la siguiente dataframe tengo los valores de intensidad 
#para cada región. Esta contiene los valores normalizados entre 0 y 1
df_normalizado

#Se guardan los resultados en un archivo .csv
df.to_csv('nina_results_no_normalizados.csv')
df_normalizado.to_csv('nina_results_normalizados.csv')
!ls

#Gráfico un plot simple
df.plot(figsize=(10,5), title='Variación de intensidad de las regiones (no normalizado)')  #ancho y altura del gráfico
plt.xlabel('Slices')
plt.ylabel('Processed intensity (a.u)')
plt.show()

#Gráfico un plot simple
df_normalizado.plot(figsize=(10,5), title='Variacion de intensidad de las regiones (normalizado)')  #ancho y altura del gráfico
plt.xlabel('Slices')
plt.ylabel('Processed intensity (a.u)')
plt.show()

"""# Comparación con los datos obtenidos en imageJ
Para evaluar si existe una diferencia entre este procedimiento y uno realizado en imageJ, se procede a graficar los datos obtenidos en python vs los datos obtenidos en ImageJ.
"""

#datos obtenidos en ImageJ
import pandas as pd
datos_imagej = pd.read_csv('resultados_nina_fiji.csv')
datos_imagej2 = analisis.normalize(datos_imagej.drop(columns='slice'))
datos_imagej2

#Se grafican los datos obtenidos en ImageJ vs los obtenidos por Tomás de la región 1
plt.figure(figsize=(20,10))
#datos de imagej
x1 = datos_imagej['slice']
y1 = datos_imagej2['imagej']
#grafico imagej
plt.plot(x1, y1, label = "Resultados ImageJ")
#datos tomás
y2 = df_normalizado['Region_1']
#gráfico tomás
plt.plot(x1, y2, label = "Resultados Tomás")
plt.xlabel('Slices')
plt.ylabel('Processed intensity (u.a)')
plt.legend()

"""# Análisis de placas de petri
Dado que el principio del análisis es el mismo que el anterior (comparar regiones circulares de radio variable), se pueden analizar regiones dentro de las placas petris, como analizar placas de petri completa

1.   Primero se hará un ejemplo de comparación de dos regiones dentro de una placa de petri
2.   Segundo se hará un ejemplo de comparación de dos placas de petri completas

# 1. Comparación de dos regiones dentro de una misma placa de petri
"""

#Para analizar las placas
image2 = ski.imread('placas.tif') #abrimos la imagen a analizar

#mostramos los frames deseados de la imagen. Esto toma un poco de tiempo
fig2 = px.imshow(image2[:150], animation_frame=0, binary_string=True, labels=dict(animation_frame="slice"), width=1000, height=1000)
fig2.show()

#Necesitamos algunos parametros para poder realizar el análisis
frames2, background2, radio2, bck_radio2, coordenadas2 = analisis.obtener_datos()

#Necesitamos algunos parametros
#Numero de frames, es decir, cuantas fotos tiene el archivo
frames2 = 232 

#coordenadas del background
background2 =  (23, 315)     #x, y

#Coordenadas de las regiones a analizar
coordenadas2 = [(32, 405), (229, 599)]  #[(x, y), (x,y),...,(x,y)]

#radio de la región
radio2 = 2

#radio de la region background
radio2_background = 2

import copy
#Copiamos la imagen para no alterar la imagen original
image2_copia = copy.copy(image2)

#Se muestra la segmentación
imagen2_segmentada = analisis.segmentar(image2_copia, coordenadas2, radio2)
px.imshow(imagen2_segmentada, height=1000, width=1000)

#Ejecuto el análisis
df2 = analisis.analisis_nina2(image2, coordenadas2, background2, radio2, bck_radio2, frames=frames2)
#Proceso los valores para que queden entre 0 y 1
df2_normalizado = analisis.normalize(df2)

#Gráfico un plot simple
df2.plot(figsize=(15,10))  #ancho y altura
plt.xlabel('Slices')
plt.ylabel('Processed intensity (a.u)')
plt.show()

#Gráfico un plot simple
df2_normalizado.plot(figsize=(15,10))  #ancho y altura
plt.xlabel('Slices')
plt.ylabel('Processed intensity (a.u)')
plt.show()

#Además, en la siguiente dataframe tengo los valores
df2

#Además, en la siguiente dataframe tengo los valores
df2_normalizado

#Se guardan los datos en formato csv
df2.to_csv('resultados_intraplaca.csv')
df2_normalizado.to_csv('resultados_intraplaca_normalizado.csv')
!ls

"""


# 2.   Analisis entre dos placas de Petri

"""

#Necesitamos algunos parametros para poder realizar el análisis
frames3, background3, radio3, bck_radio3, coordenadas3 = analisis.obtener_datos()

#Necesitamos algunos parametros
#Numero de frames, es decir, cuantas fotos tiene el archivo
frames3 = 232 

#coordenadas del background
background3 =  (23, 315)     #x, y

#Coordenadas de las regiones a analizar
coordenadas3 = [(473, 845), (813, 845)]  #[(x, y), (x,y),...,(x,y)]

#radio de la región
radio3 = 157

#radio de la region background
radio3_background = 4

import copy
#Se copia la imagen para no alterar la imagen original
image3_copia = copy.copy(image2)
#Se muestra la segmentación
imagen3_segmentada = analisis.segmentar(image3_copia, coordenadas=coordenadas3, radio=radio3)
px.imshow(imagen3_segmentada, height=1000, width=1000)

#Ejecuto el análisis
df3 = analisis.analisis_nina2(image2, coordenadas3, background3, radio3, bck_radio3, frames=frames3)
#Proceso los valores para que queden entre 0 y 1
df3_normalizado = analisis.normalize(df3)

#Gráfico un plot simple
df3.plot(figsize=(15,10))  #ancho y altura
plt.xlabel('Slices')
plt.ylabel('Raw intensity')
plt.show()

#Gráfico un plot simple
df3_normalizado.plot(figsize=(15,10))  #ancho y altura
plt.xlabel('Slices')
plt.ylabel('Raw intensity')
plt.show()

#Además, en la siguiente dataframe tengo los valores
df3

#Resultados normalizados
df3_normalizado

#Se guardan los datos en formato csv
df3.to_csv('resultados_interplaca.csv')
df3_normalizado.to_csv('resultados_interplaca_normalizado.csv')
!ls
